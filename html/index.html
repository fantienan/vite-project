<!DOCTYPE html>
<html>
  <head>
    <title>Accessible Map</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="./ol.css" type="text/css">
    <!-- The line below is only needed for old environments like Internet Explorer and Android 4.x -->
    <script src="./ol-4.6.5.js"></script>
    <style>
      a.skiplink {
        position: absolute;
        clip: rect(1px, 1px, 1px, 1px);
        padding: 0;
        border: 0;
        height: 1px;
        width: 1px;
        overflow: hidden;
      }
      a.skiplink:focus {
        clip: auto;
        height: auto;
        width: auto;
        background-color: #fff;
        padding: 0.3em;
      }
      #map:focus {
        outline: #4A74A8 solid 0.15em;
      }
    </style>
  </head>
  <body>
    <div id="map" class="map" tabindex="0"></div>
    <div style="display: flex;">
      <div id="total"></div>

      <select id="featuer-select">
        <option value="all">全部</option>
      </select>
        <button id="data-btn">获取数据</button>
        <button id="enable-btn">查看轨迹</button>
        <button id="clear-btn">清空轨迹</button>
    </div>
    <script >
        async function main () {
          var map = new ol.Map({
            layers: [
              new ol.layer.Tile({ source: new ol.source.OSM() }) 
            ],
            target: 'map',
            controls: ol.control.defaults({
              attributionOptions: {
                collapsible: false
              }
            }),
            view: new ol.View({
              center: [12288470.692939252, -1565430.3392804065],
              minZoom: 2,
              zoom: 2
            })
          });
          window._map = map

          var vectorLayer = new ol.layer.Vector({
            source: new ol.source.Vector({
              features: []
            }),
            style: new ol.style.Style({
              image: new ol.style.Circle({

                radius: 6,
                fill: new ol.style.Fill({
                  color: 'red'
                }),
                stroke: new ol.style.Stroke({
                  color: 'white',
                  width: 2
                })
              })
            })
          });
          map.addLayer(vectorLayer);

      document.getElementById("clear-btn").addEventListener("click", function() {
        vectorSource.clear();
      });

      document.getElementById("data-btn").addEventListener("click", async function() {
          const res = await fetch('./xh_realtime_point.txt').then(res => res.text())
          if (!res) return

          const features = []
          const errorData = []
          const data = res.split('\n')
          const fieldnames = data[0].split(',').map(item => item.replaceAll('\r',''));
          const dataSource = data.slice(1).map(item => {
            const obj = {}
            const arr = item.split(',')
            fieldnames.forEach((field, index) => {
              obj[field] = (arr[index]??"").replaceAll("|",'').replaceAll("\r",'').trim();
            })
            if (arr.length !== fieldnames.length){
              errorData.push(obj);
            } else {
              features.push(new ol.Feature({
                geometry: new ol.geom.Point(ol.proj.fromLonLat([obj.lon, obj.lat]))
              })) 
              return obj
            }
          }).filter(item => item)
          document.getElementById('total').innerHTML = `总共${dataSource.length}条数据，错误${errorData.length}条数据`

          const html = Array(Math.floor(features.length / 10000)).fill().map((item, index) => {
            if (index === 0) {
              return `<option value="all">全部</option>`
            }
            return `<option value="${index * 10000}">${`${index}万`}</option>`
          }).join('');
          let value = 'all'
          document.getElementById('featuer-select').innerHTML =html; 
          document.getElementById('featuer-select').addEventListener('change', (e) => {
            value = e.target.value
            vectorLayer.getSource().clear()
          })

          document.getElementById("enable-btn").addEventListener("click", function() {
            if (value === 'all') {
              vectorLayer.getSource().clear()
              vectorLayer.getSource().addFeatures(features)
            } else {
              const filterFeatures = features.slice(0,value);
              vectorLayer.getSource().clear()
              vectorLayer.getSource().addFeatures(filterFeatures)
            }
          })
        })

      
      }
        main();

// const Units = {
//     "RADIANS": "radians",
//     "DEGREES": "degrees",
//     "FEET": "ft",
//     "METERS": "m",
//     "PIXELS": "pixels",
//     "TILE_PIXELS": "tile-pixels",
//     "USFEET": "us-ft"
// };
// function getResolutions(firstDpi) {
//   const resolution = firstDpi || 360 / 256;
//   const resolutions = [];
//   const matrixIds = [];
//   for (let z = 0; z <= maxZoom; z += 1) {
//     resolutions[z] = resolution / 2 ** z;
//     matrixIds[z] = z.toString();
//   }
//   return {
//     resolutions,
//     matrixIds,
//   };
// }
// const mask = '';
// const crossOrigin = 'Anonymous';
// const epsg = 'EPSG:4490';
// const maxZoom = 21;
// const paramString = "mapId=1619404b-b6f6-4cf7-b9ec-705a0c3f977e&maps=1619404b-b6f6-4cf7-b9ec-705a0c3f977e";
// let tileGrid = undefined;
// const projection = new ol.proj.Projection({ code: epsg, units: Units.DEGREES });
// const layerConfig = await fetch('./2019-image.json').then(res => res.json());
// const rs = getResolutions(+layerConfig.d_firstDpi);
// if (layerConfig.srid !== 3857) {
//   tileGrid = new ol.tilegrid.TileGrid({
//     extent: JSON.parse(layerConfig.c_extent),
//     origin: JSON.parse(layerConfig.c_origin),
//     resolutions: rs.resolutions,
//     tileSize: 256,
//   });
// }
// const xyzSource = new ol.source.XYZ({
//   projection: layerConfig.srid ? `EPSG:${layerConfig.srid}` : projection,
//   crossOrigin,
//   tileGrid,
//   cacheSize: 0,
//   tileUrlFunction: function(tileCoord) {
//     let url = layerConfig.c_url.trim() + layerConfig.c_path.trim();
//     let z = tileCoord[0];
//     let x = tileCoord[1];
//     let y = tileCoord[2];
//     url += url.indexOf('?') === -1 ? '?' : '&';
//     url += `t=${new Date().getTime()}&${paramString}`;
//     if (url.indexOf('mask') > -1) {
//       url = url.replace(/{mask}/, mask);
//     }
//     url = url.replace('{z}', z.toString()).replace('{y}', y.toString()).replace('{x}', x.toString());
//     return url;
//   },
// });
// const tileLayer = new ol.layer.Tile({
//   source: xyzSource,
//   zIndex: layerConfig.i_zIndex,
//   visible: !!layerConfig.i_visible,
//   opacity: layerConfig.d_opacity,
//   maxResolution: rs.resolutions[layerConfig.i_minLevel],
//   minResolution: rs.resolutions[layerConfig.i_maxLevel],
  
// });
// const layer = new ol.layer.Tile({ source: new ol.source.OSM() });
// const view = new ol.View({
//   center: [104.13669144100015, 29.2878471785001],
//   maxZoom: 22,
//   minZoom: 1,
//   projection,
//   extent: [-180, -90, 180, 90],
//   zoom: 5,
// });
// const map = new ol.Map({ target: 'map', layers: [tileLayer, layer], view });
    </script>
  </body>
</html>
